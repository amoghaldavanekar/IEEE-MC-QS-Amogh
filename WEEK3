/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

E1:
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode curr=head;
        while(curr!=null && curr.next!=null){
            if(curr.val==curr.next.val){
                curr.next=curr.next.next;
            }
            else{
                curr=curr.next;
            }
        }
        return head;
    }
}

E2:
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode head1 = new ListNode(0);
        ListNode curr = head;
        while(curr!=null){
            ListNode nextTemp = curr.next;
            ListNode prev = head1;
            while(prev.next!=null && prev.next.val<curr.val){
                prev=prev.next;
            }
            curr.next=prev.next;
            prev.next= curr;
            curr= nextTemp;
        }
        return head1.next;
    }
}

E3:
class MyCircularQueue {
    int[] data;
    int head;
    int count;
    int capacity;
    public MyCircularQueue(int k) {
        this.capacity=k;
        this.data= new int[k];
        this.head=0;
        this.count=0;
    }
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        int tail = (head+count)%capacity;
        data[tail]=value;
        count++;
        return true;
    }
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        head=(head+1)%capacity;
        count--;
        return true;
    }
    public int Front(){
        if(isEmpty()){
            return -1;
        }
        return data[head];
    }    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        int tail = (head+count-1)%capacity;
        return data[tail];
    }
    public boolean isEmpty() {
        return count ==0;
    }
    public boolean isFull() {
        return count == capacity;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */

E4:
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack<>();
        for(int ast: asteroids){
            boolean isExploded = false;
            while(!stack.isEmpty() && ast<0 && stack.peek()>0){
                int diff = ast + stack.peek();
                if(diff<0){
                    stack.pop();
                }
                else if(diff>0){
                    isExploded=true;
                    break;
                }
                else{
                    stack.pop();
                    isExploded=true;
                    break;
                }
            }
            if(!isExploded){
                stack.push(ast);
            }
        }
        int[] result = new int[stack.size()];
        for(int i= result.length -1; i>=0; i--){
            result[i]=stack.pop();
        }
        return result;
    }
}

E5:
class Solution {
    public int findTheWinner(int n, int k) {
        int w=0;
        for(int i=2; i<=n; i++){
            w=(w+k)%i;
        }
        return w+1;
    }
}
